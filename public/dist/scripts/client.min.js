'use strict';

angular.module('app', ['ui.router', 'ngDialog']).config(['$stateProvider', '$urlRouterProvider', routing]);

function routing($stateProvider, $urlRouterProvider) {

	$urlRouterProvider.otherwise('/');

	$stateProvider.state('login', {
		url: '/',
		templateUrl: './dist/html/loginView/loginView.html',
		controller: 'loginViewCtrl'
	}).state('about', {
		url: '/about',
		templateUrl: './dist/html/aboutView/about.html'
	}).state('learnMore', {
		url: '/learnmore',
		templateUrl: './dist/html/learnMoreView/learnMore.html'
	}).state('userHome', {
		url: '/userhome',
		templateUrl: './dist/html/userHomeView/userHome.html',
		controller: 'userHomeCtrl'
	}).state('gallery', {
		url: '/gallery',
		templateUrl: './dist/html/userHomeView/gallery.html'
	}).state('settings', {
		url: '/settings',
		templateUrl: './dist/html/userHomeView/settings.html'
	});
}
'use strict';

angular.module('app').service('authService', ['$q', '$http', authService]);

function authService($q, $http) {

	this.getAuthedUser = function () {
		return $http.get("/getAuthedUser").then(function (response) {
			return response.data;
		});
	};
}
'use strict';

angular.module('app').service('familyService', ['$q', '$http', familyService]);

function familyService($q, $http) {
	var _this = this;

	var ancestry = [];
	var ancestryAndChildren = [];
	var self = this;

	this.returnAncestry = function () {
		return self.ancestry;
	};

	this.returnAncestryAndChildren = function () {
		return self.ancestryAndChildren;
	};

	//Here we make the API call for direct ancestors and save their information.
	this.getAncestryAndChildren = function (personId, accessToken) {
		var defer = $q.defer();
		if (!_this.ancestry) {
			makeAncestryCall.call(_this, personId, accessToken, defer).then(function (response) {
				response.data.persons.forEach(function (person) {
					ancestry.push({
						personId: person.id,
						name: person.display.name,
						gender: person.display.gender,
						lifespan: person.display.lifespan,
						birthDate: person.display.birthDate,
						birthPlace: person.display.birthPlace,
						deathDate: person.display.deathDate,
						deathPlace: person.display.deathPlace,
						marriagePlace: person.display.marriagePlace,
						marriageDate: person.display.marriageDate,
						ascendancyNumber: person.display.ascendancyNumber
					});
				});
				self.ancestry = ancestry;

				//Here we make each direct ancestor into a 'parent' and then make the API call to fill in their children.
				self.ancestry.forEach(function (person) {

					if (person.ascendancyNumber > 1 && person.ascendancyNumber < 512 && person.ascendancyNumber % 2 === 0) {

						var parent = {
							personId: person.id,
							name: person.name,
							gender: person.gender,
							lifespan: person.lifespan,
							birthDate: person.birthDate,
							birthPlace: person.birthPlace,
							deathDate: person.deathDate,
							deathPlace: person.deathPlace,
							marriagePlace: person.marriagePlace,
							marriageDate: person.marriageDate,
							ascendancyNumber: person.ascendancyNumber,
							children: []
						};

						makeAncestryAndChildrenCall.call(this, accessToken, defer, person).then(function (response) {

							response.data.persons.forEach(function (child) {

								if (child.display.descendancyNumber !== "1" && !/[S]/.test(child.display.descendancyNumber)) {

									parent.children.push({
										personId: child.id,
										name: child.display.name,
										gender: child.display.gender,
										lifespan: child.display.lifespan,
										birthDate: child.display.birthDate,
										birthPlace: child.display.birthPlace,
										deathDate: child.display.deathDate,
										deathPlace: child.display.deathPlace,
										marriagePlace: child.display.marriagePlace,
										marriageDate: child.display.marriageDate,
										descendancyNumber: child.display.descendancyNumber
									});
								}
							});
							ancestryAndChildren.push(parent);
							self.ancestryAndChildren = ancestryAndChildren;
							defer.resolve(self.ancestryAndChildren);
						});
					}
				});
			});
		}
		return defer.promise;
	};

	//Helper function that makes the API call for direct ancestors
	function makeAncestryCall(personId, accessToken, defer) {
		var req = {
			method: 'GET',
			url: 'https://sandbox.familysearch.org/platform/tree/ancestry.json?person=' + personId + '&spouse=&personDetails=&generations=8&marriageDetails=',
			headers: {
				'Accept': 'application/x-fs-v1+json',
				'Authorization': 'Bearer ' + accessToken,
				'Content-Type': 'application/json;charset=UTF-8'
			}
		};
		return $http(req);
	}

	//Helper function that makes the API call for children of direct ancestors
	function makeAncestryAndChildrenCall(accessToken, defer, person) {
		var req = {
			method: 'GET',
			url: 'https://sandbox.familysearch.org/platform/tree/descendancy.json?person=' + person.personId + '&personDetails=&marriageDetails=',
			headers: {
				'Accept': 'application/x-fs-v1+json',
				'Authorization': 'Bearer ' + accessToken,
				'Content-Type': 'application/json;charset=UTF-8'
			}
		};
		return $http(req);
	}
}
'use strict';

angular.module('app').controller('chart1Controller', ["$scope", function ($scope) {
	var whatever = "hey guys";

	$scope.test = whatever;

	console.log("this is our const test", $scope.test);
}]);
'use strict';

angular.module('app').controller('birthMonthCtrl', ["$scope", function ($scope) {}]);
'use strict';

angular.module('app').directive('birthMonth', ["$parse", "$window", function ($parse, $window) {

    return {
        restrict: 'EA',
        templateUrl: './dist/html/home-chart/home-chart-temp.html',
        controller: 'birthMonthCtrl',
        link: function link(scope, elem, attrs) {

            // Dimensions of sunburst.
            var width = 750;
            var height = 600;
            var radius = Math.min(width, height) / 2;

            // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
            var b = {
                w: 75, h: 30, s: 3, t: 10
            };

            // Mapping of step names to colors.
            var colors = {
                "home": "#5687d1",
                "product": "#7b615c",
                "search": "#de783b",
                "account": "#6ab975",
                "other": "#a173d1",
                "end": "#bbbbbb"
            };

            // Total size of all segments; we set this later, after loading the data.
            var totalSize = 0;

            var vis = d3.select("#chart").append("svg:svg").attr("width", width).attr("height", height).append("svg:g").attr("id", "container").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

            var partition = d3.layout.partition().size([2 * Math.PI, radius * radius]).value(function (d) {
                return d.size;
            });

            var arc = d3.svg.arc().startAngle(function (d) {
                return d.x;
            }).endAngle(function (d) {
                return d.x + d.dx;
            }).innerRadius(function (d) {
                return Math.sqrt(d.y);
            }).outerRadius(function (d) {
                return Math.sqrt(d.y + d.dy);
            });

            // Use d3.text and d3.csv.parseRows so that we do not need to have a header
            // row, and can receive the csv as an array of arrays.
            d3.text("visit-sequences.csv", function (text) {
                var csv = d3.csv.parseRows(text);
                var json = buildHierarchy(csv);
                createVisualization(json);
            });

            // Main function to draw and set up the visualization, once we have the data.
            function createVisualization(json) {

                // Basic setup of page elements.
                initializeBreadcrumbTrail();
                drawLegend();
                d3.select("#togglelegend").on("click", toggleLegend);

                // Bounding circle underneath the sunburst, to make it easier to detect
                // when the mouse leaves the parent g.
                vis.append("svg:circle").attr("r", radius).style("opacity", 0);

                // For efficiency, filter nodes to keep only those large enough to see.
                var nodes = partition.nodes(json).filter(function (d) {
                    return d.dx > 0.005; // 0.005 radians = 0.29 degrees
                });

                var path = vis.data([json]).selectAll("path").data(nodes).enter().append("svg:path").attr("display", function (d) {
                    return d.depth ? null : "none";
                }).attr("d", arc).attr("fill-rule", "evenodd").style("fill", function (d) {
                    return colors[d.name];
                }).style("opacity", 1).on("mouseover", mouseover);

                // Add the mouseleave handler to the bounding circle.
                d3.select("#container").on("mouseleave", mouseleave);

                // Get total size of the tree = value of root node from partition.
                totalSize = path.node().__data__.value;
            };

            // Fade all but the current sequence, and show it in the breadcrumb trail.
            function mouseover(d) {

                var percentage = (100 * d.value / totalSize).toPrecision(3);
                var percentageString = percentage + "%";
                if (percentage < 0.1) {
                    percentageString = "< 0.1%";
                }

                d3.select("#percentage").text(percentageString);

                d3.select("#explanation").style("visibility", "");

                var sequenceArray = getAncestors(d);
                updateBreadcrumbs(sequenceArray, percentageString);

                // Fade all the segments.
                d3.selectAll("path").style("opacity", 0.3);

                // Then highlight only those that are an ancestor of the current segment.
                vis.selectAll("path").filter(function (node) {
                    return sequenceArray.indexOf(node) >= 0;
                }).style("opacity", 1);
            }

            // Restore everything to full opacity when moving off the visualization.
            function mouseleave(d) {

                // Hide the breadcrumb trail
                d3.select("#trail").style("visibility", "hidden");

                // Deactivate all segments during transition.
                d3.selectAll("path").on("mouseover", null);

                // Transition each segment to full opacity and then reactivate it.
                d3.selectAll("path").transition().duration(1000).style("opacity", 1).each("end", function () {
                    d3.select(this).on("mouseover", mouseover);
                });

                d3.select("#explanation").style("visibility", "hidden");
            }

            // Given a node in a partition layout, return an array of all of its ancestor
            // nodes, highest first, but excluding the root.
            function getAncestors(node) {
                var path = [];
                var current = node;
                while (current.parent) {
                    path.unshift(current);
                    current = current.parent;
                }
                return path;
            }

            function initializeBreadcrumbTrail() {
                // Add the svg area.
                var trail = d3.select("#sequence").append("svg:svg").attr("width", width).attr("height", 50).attr("id", "trail");
                // Add the label at the end, for the percentage.
                trail.append("svg:text").attr("id", "endlabel").style("fill", "#000");
            }

            // Generate a string that describes the points of a breadcrumb polygon.
            function breadcrumbPoints(d, i) {
                var points = [];
                points.push("0,0");
                points.push(b.w + ",0");
                points.push(b.w + b.t + "," + b.h / 2);
                points.push(b.w + "," + b.h);
                points.push("0," + b.h);
                if (i > 0) {
                    // Leftmost breadcrumb; don't include 6th vertex.
                    points.push(b.t + "," + b.h / 2);
                }
                return points.join(" ");
            }

            // Update the breadcrumb trail to show the current sequence and percentage.
            function updateBreadcrumbs(nodeArray, percentageString) {

                // Data join; key function combines name and depth (= position in sequence).
                var g = d3.select("#trail").selectAll("g").data(nodeArray, function (d) {
                    return d.name + d.depth;
                });

                // Add breadcrumb and label for entering nodes.
                var entering = g.enter().append("svg:g");

                entering.append("svg:polygon").attr("points", breadcrumbPoints).style("fill", function (d) {
                    return colors[d.name];
                });

                entering.append("svg:text").attr("x", (b.w + b.t) / 2).attr("y", b.h / 2).attr("dy", "0.35em").attr("text-anchor", "middle").text(function (d) {
                    return d.name;
                });

                // Set position for entering and updating nodes.
                g.attr("transform", function (d, i) {
                    return "translate(" + i * (b.w + b.s) + ", 0)";
                });

                // Remove exiting nodes.
                g.exit().remove();

                // Now move and update the percentage at the end.
                d3.select("#trail").select("#endlabel").attr("x", (nodeArray.length + 0.5) * (b.w + b.s)).attr("y", b.h / 2).attr("dy", "0.35em").attr("text-anchor", "middle").text(percentageString);

                // Make the breadcrumb trail visible, if it's hidden.
                d3.select("#trail").style("visibility", "");
            }

            function drawLegend() {

                // Dimensions of legend item: width, height, spacing, radius of rounded rect.
                var li = {
                    w: 75, h: 30, s: 3, r: 3
                };

                var legend = d3.select("#legend").append("svg:svg").attr("width", li.w).attr("height", d3.keys(colors).length * (li.h + li.s));

                var g = legend.selectAll("g").data(d3.entries(colors)).enter().append("svg:g").attr("transform", function (d, i) {
                    return "translate(0," + i * (li.h + li.s) + ")";
                });

                g.append("svg:rect").attr("rx", li.r).attr("ry", li.r).attr("width", li.w).attr("height", li.h).style("fill", function (d) {
                    return d.value;
                });

                g.append("svg:text").attr("x", li.w / 2).attr("y", li.h / 2).attr("dy", "0.35em").attr("text-anchor", "middle").text(function (d) {
                    return d.key;
                });
            }

            function toggleLegend() {
                var legend = d3.select("#legend");
                if (legend.style("visibility") == "hidden") {
                    legend.style("visibility", "");
                } else {
                    legend.style("visibility", "hidden");
                }
            }

            // Take a 2-column CSV and transform it into a hierarchical structure suitable
            // for a partition layout. The first column is a sequence of step names, from
            // root to leaf, separated by hyphens. The second column is a count of how
            // often that sequence occurred.
            function buildHierarchy(csv) {
                var root = { "name": "root", "children": [] };
                for (var i = 0; i < csv.length; i++) {
                    var sequence = csv[i][0];
                    var size = +csv[i][1];
                    if (isNaN(size)) {
                        // e.g. if this is a header row
                        continue;
                    }
                    var parts = sequence.split("-");
                    var currentNode = root;
                    for (var j = 0; j < parts.length; j++) {
                        var children = currentNode["children"];
                        var nodeName = parts[j];
                        var childNode;
                        if (j + 1 < parts.length) {
                            // Not yet at the end of the sequence; move down the tree.
                            var foundChild = false;
                            for (var k = 0; k < children.length; k++) {
                                if (children[k]["name"] == nodeName) {
                                    childNode = children[k];
                                    foundChild = true;
                                    break;
                                }
                            }
                            // If we don't already have a child node for this branch, create it.
                            if (!foundChild) {
                                childNode = { "name": nodeName, "children": [] };
                                children.push(childNode);
                            }
                            currentNode = childNode;
                        } else {
                            // Reached the end of the sequence; create a leaf node.
                            childNode = { "name": nodeName, "size": size };
                            children.push(childNode);
                        }
                    }
                }
                return root;
            };
        }
    };
}]);
'use strict';

angular.module('app').controller('homeChartCtrl', ["$scope", "$interval", function ($scope, $interval) {

    $scope.salesData = [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95], [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]];

    $interval(function () {
        var hour = $scope.salesData.length + 1;
        var sales = Math.round(Math.random() * 100);
        $scope.salesData.push({ hour: hour, sales: sales });
    }, 1000, 10);
}]);
'use strict';

angular.module('app').directive('linearChart', ["$parse", "$window", function ($parse, $window) {

    return {
        restrict: 'EA',
        templateUrl: './dist/html/home-chart/home-chart-temp.html',
        controller: 'homeChartCtrl',
        link: function link(scope, elem, attrs) {
            var _this = this;

            var dataset = [];

            // Setup data
            var numDataPoints = 20; // Number of dummy data points
            var maxRange = Math.random() * 1000; // Max range of new values
            for (var i = 0; i < numDataPoints; i++) {
                var newNumber1 = Math.floor(Math.random() * maxRange) + 25; // New random integer
                var newNumber2 = Math.floor(Math.random() * maxRange) + 50; // New random integer
                dataset.push([newNumber1, newNumber2]); // Add new number to array
            }

            // Setup settings for graphic
            var canvas_width = 1000;
            var canvas_height = 350;
            var padding = 30; // for chart edges

            console.log("this is dataset", dataset);
            // Create scale functions
            var xScale = d3.scale.linear() // xScale is width of graphic
            .domain([0, d3.max(dataset, function (d) {
                return d[0]; // input domain
            })]).range([padding, canvas_width - padding * 2]); // output range

            var yScale = d3.scale.linear() // yScale is height of graphic
            .domain([0, d3.max(dataset, function (d) {
                return d[1]; // input domain
            })]).range([canvas_height - padding, padding]); // remember y starts on top going down so we flip

            // Define X axis
            var xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(0);

            // Define Y axis
            var yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(0);

            // Create SVG element
            var svg = d3.select("h3") // This is where we put our vis
            .append("svg").attr("width", canvas_width).attr("height", canvas_height);

            //randomize radius size
            function randomizeRadius() {
                return Math.round(Math.random() * 25 + 5);
            }
            //pick either blue or orange
            function colorPicker() {
                var randomizer = Math.floor(Math.random() * 2);
                console.log("this is randomizer", randomizer);
                if (randomizer === 0) {
                    return 'rgba(248, 158, 49, .8)';
                } else {
                    return 'rgba(0, 114, 188, .95)';
                }
            }
            // Create Circles
            svg.selectAll("circle").data(dataset).enter().append("circle") // Add circle svg
            .attr("cx", function (d) {
                return xScale(d[0]); // Circle's X
            }).attr("cy", function (d) {
                // Circle's Y
                return yScale(d[1]);
            }).attr("r", function () {
                return randomizeRadius();
            }) // radius
            .attr("fill", function () {
                return colorPicker();
            });

            // Add to X axis
            svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + (canvas_height - padding) + ")").call(xAxis);

            // Add to Y axis
            svg.append("g").attr("class", "y axis").attr("transform", "translate(" + padding + ",0)").call(yAxis);

            // On interval, update with new data
            setInterval(function () {
                console.log("this is svg", svg);
                d3.select("h4");
                console.log("you clicked me!");
                var numValues = dataset.length; // Get original dataset's length
                var maxRange = Math.random() * 1000; // Get max range of new values
                dataset = []; // Initialize empty array
                for (var _i = 0; _i < numValues; _i++) {
                    var _newNumber = Math.floor(Math.random() * maxRange) + 25; // Random int for x
                    var _newNumber2 = Math.floor(Math.random() * maxRange) + 50; // Random int for y
                    dataset.push([_newNumber, _newNumber2]); // Add new numbers to array
                }

                // Update scale domains
                xScale.domain([0, d3.max(dataset, function (d) {
                    return d[0];
                })]);
                yScale.domain([0, d3.max(dataset, function (d) {
                    return d[1];
                })]);

                // Update circles
                svg.selectAll("circle").data(dataset) // Update with new data
                .transition() // Transition from old to new
                .duration(1000) // Length of animation
                .each("start", function () {
                    // Start animation
                    d3.select(_this) // 'this' means the current element
                    .attr("fill", "gray") // Change color
                    .attr("r", 5); // Change size
                }).delay(function (d, i) {
                    return i / dataset.length * 500; // Dynamic delay (i.e. each item delays a little longer)
                })
                //.ease("linear")  // Transition easing - default 'variable' (i.e. has acceleration), also: 'circle', 'elastic', 'bounce', 'linear'
                .attr("cx", function (d) {
                    return xScale(d[0]); // Circle's X
                }).attr("cy", function (d) {
                    return yScale(d[1]); // Circle's Y
                }).each("end", function () {
                    // End animation
                    d3.select(_this) // 'this' means the current element
                    .transition().duration(500).attr("fill", function () {
                        return colorPicker();
                    }) // Change color
                    .attr("r", function () {
                        return randomizeRadius();
                    }); // Change radius
                });

                // Update X Axis
                svg.select(".x.axis").transition().duration(1000).call(xAxis);

                // Update Y Axis
                svg.select(".y.axis").transition().duration(100).call(yAxis);
            }, 3000);
        }
    };
}]);
'use strict';

angular.module('app').directive('infoBoxDir', function () {

	return {
		restrict: "E",
		templateUrl: "./dist/html/infoBoxes/infoBoxTmp.html",
		scope: {
			infoBox: '='
		}
	};
});
'use strict';

angular.module('app').controller('loginViewCtrl', ["$scope", function ($scope) {

	$scope.pieChartBox = {
		icon: 'images/pieChartIcon.png',
		text: 'Your families legacy, intelligently organized and exhibited.',
		class: 'pie-chart'
	};

	$scope.treeBox = {
		icon: 'images/treeIcon.png',
		text: 'See your family tree displayed in stunningly beautiful visualizations.',
		class: 'tree-icon'
	};

	$scope.gearBox = {
		icon: 'images/gearIcon.png',
		text: 'Change settings to view interactive charts based on preferences, statistics, gender, and more.',
		class: 'gear-icon'
	};
}]);
'use strict';

angular.module('app').controller('menuBarCtrl', ["$scope", "ngDialog", "$state", function ($scope, ngDialog, $state) {

  $scope.openLoginModal = function () {
    ngDialog.open({
      template: './dist/html/menuBar/loginModalTmp.html',
      scope: $scope
    });
  };
}]);
'use strict';

angular.module('app').directive('menuBarDir', function () {

	return {
		restrict: "E",
		templateUrl: "./dist/html/menuBar/MenuBarTmp.html",
		controller: "menuBarCtrl"
	};
});
'use strict';

/*
 * ngDialog - easy modals and popup windows
 * http://github.com/likeastore/ngDialog
 * (c) 2013-2015 MIT License, https://likeastore.com
 */

(function (root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        if (typeof angular === 'undefined') {
            factory(require('angular'));
        } else {
            factory(angular);
        }
        module.exports = 'ngDialog';
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(['angular'], factory);
    } else {
        // Global Variables
        factory(window.angular);
    }
})(undefined, function (angular) {
    'use strict';

    var m = angular.module('ngDialog', []);

    var $el = angular.element;
    var isDef = angular.isDefined;
    var style = (document.body || document.documentElement).style;
    var animationEndSupport = isDef(style.animation) || isDef(style.WebkitAnimation) || isDef(style.MozAnimation) || isDef(style.MsAnimation) || isDef(style.OAnimation);
    var animationEndEvent = 'animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend';
    var focusableElementSelector = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
    var disabledAnimationClass = 'ngdialog-disabled-animation';
    var forceElementsReload = { html: false, body: false };
    var scopes = {};
    var openIdStack = [];
    var keydownIsBound = false;

    m.provider('ngDialog', function () {
        var defaults = this.defaults = {
            className: 'ngdialog-theme-default',
            disableAnimation: false,
            plain: false,
            showClose: true,
            closeByDocument: true,
            closeByEscape: true,
            closeByNavigation: false,
            appendTo: false,
            preCloseCallback: false,
            overlay: true,
            cache: true,
            trapFocus: true,
            preserveFocus: true,
            ariaAuto: true,
            ariaRole: null,
            ariaLabelledById: null,
            ariaLabelledBySelector: null,
            ariaDescribedById: null,
            ariaDescribedBySelector: null
        };

        this.setForceHtmlReload = function (_useIt) {
            forceElementsReload.html = _useIt || false;
        };

        this.setForceBodyReload = function (_useIt) {
            forceElementsReload.body = _useIt || false;
        };

        this.setDefaults = function (newDefaults) {
            angular.extend(defaults, newDefaults);
        };

        var globalID = 0,
            dialogsCount = 0,
            closeByDocumentHandler,
            defers = {};

        this.$get = ['$document', '$templateCache', '$compile', '$q', '$http', '$rootScope', '$timeout', '$window', '$controller', '$injector', function ($document, $templateCache, $compile, $q, $http, $rootScope, $timeout, $window, $controller, $injector) {
            var $elements = [];

            var privateMethods = {
                onDocumentKeydown: function onDocumentKeydown(event) {
                    if (event.keyCode === 27) {
                        publicMethods.close('$escape');
                    }
                },

                activate: function activate($dialog) {
                    var options = $dialog.data('$ngDialogOptions');

                    if (options.trapFocus) {
                        $dialog.on('keydown', privateMethods.onTrapFocusKeydown);

                        // Catch rogue changes (eg. after unfocusing everything by clicking a non-focusable element)
                        $elements.body.on('keydown', privateMethods.onTrapFocusKeydown);
                    }
                },

                deactivate: function deactivate($dialog) {
                    $dialog.off('keydown', privateMethods.onTrapFocusKeydown);
                    $elements.body.off('keydown', privateMethods.onTrapFocusKeydown);
                },

                deactivateAll: function deactivateAll(els) {
                    angular.forEach(els, function (el) {
                        var $dialog = angular.element(el);
                        privateMethods.deactivate($dialog);
                    });
                },

                setBodyPadding: function setBodyPadding(width) {
                    var originalBodyPadding = parseInt($elements.body.css('padding-right') || 0, 10);
                    $elements.body.css('padding-right', originalBodyPadding + width + 'px');
                    $elements.body.data('ng-dialog-original-padding', originalBodyPadding);
                    $rootScope.$broadcast('ngDialog.setPadding', width);
                },

                resetBodyPadding: function resetBodyPadding() {
                    var originalBodyPadding = $elements.body.data('ng-dialog-original-padding');
                    if (originalBodyPadding) {
                        $elements.body.css('padding-right', originalBodyPadding + 'px');
                    } else {
                        $elements.body.css('padding-right', '');
                    }
                    $rootScope.$broadcast('ngDialog.setPadding', 0);
                },

                performCloseDialog: function performCloseDialog($dialog, value) {
                    var options = $dialog.data('$ngDialogOptions');
                    var id = $dialog.attr('id');
                    var scope = scopes[id];

                    if (!scope) {
                        // Already closed
                        return;
                    }

                    if (typeof $window.Hammer !== 'undefined') {
                        var hammerTime = scope.hammerTime;
                        hammerTime.off('tap', closeByDocumentHandler);
                        hammerTime.destroy && hammerTime.destroy();
                        delete scope.hammerTime;
                    } else {
                        $dialog.unbind('click');
                    }

                    if (dialogsCount === 1) {
                        $elements.body.unbind('keydown', privateMethods.onDocumentKeydown);
                    }

                    if (!$dialog.hasClass('ngdialog-closing')) {
                        dialogsCount -= 1;
                    }

                    var previousFocus = $dialog.data('$ngDialogPreviousFocus');
                    if (previousFocus && previousFocus.focus) {
                        previousFocus.focus();
                    }

                    $rootScope.$broadcast('ngDialog.closing', $dialog, value);
                    dialogsCount = dialogsCount < 0 ? 0 : dialogsCount;
                    if (animationEndSupport && !options.disableAnimation) {
                        scope.$destroy();
                        $dialog.unbind(animationEndEvent).bind(animationEndEvent, function () {
                            privateMethods.closeDialogElement($dialog, value);
                        }).addClass('ngdialog-closing');
                    } else {
                        scope.$destroy();
                        privateMethods.closeDialogElement($dialog, value);
                    }
                    if (defers[id]) {
                        defers[id].resolve({
                            id: id,
                            value: value,
                            $dialog: $dialog,
                            remainingDialogs: dialogsCount
                        });
                        delete defers[id];
                    }
                    if (scopes[id]) {
                        delete scopes[id];
                    }
                    openIdStack.splice(openIdStack.indexOf(id), 1);
                    if (!openIdStack.length) {
                        $elements.body.unbind('keydown', privateMethods.onDocumentKeydown);
                        keydownIsBound = false;
                    }
                },

                closeDialogElement: function closeDialogElement($dialog, value) {
                    $dialog.remove();
                    if (dialogsCount === 0) {
                        $elements.html.removeClass('ngdialog-open');
                        $elements.body.removeClass('ngdialog-open');
                        privateMethods.resetBodyPadding();
                    }
                    $rootScope.$broadcast('ngDialog.closed', $dialog, value);
                },

                closeDialog: function closeDialog($dialog, value) {
                    var preCloseCallback = $dialog.data('$ngDialogPreCloseCallback');

                    if (preCloseCallback && angular.isFunction(preCloseCallback)) {

                        var preCloseCallbackResult = preCloseCallback.call($dialog, value);

                        if (angular.isObject(preCloseCallbackResult)) {
                            if (preCloseCallbackResult.closePromise) {
                                preCloseCallbackResult.closePromise.then(function () {
                                    privateMethods.performCloseDialog($dialog, value);
                                });
                            } else {
                                preCloseCallbackResult.then(function () {
                                    privateMethods.performCloseDialog($dialog, value);
                                }, function () {
                                    return;
                                });
                            }
                        } else if (preCloseCallbackResult !== false) {
                            privateMethods.performCloseDialog($dialog, value);
                        }
                    } else {
                        privateMethods.performCloseDialog($dialog, value);
                    }
                },

                onTrapFocusKeydown: function onTrapFocusKeydown(ev) {
                    var el = angular.element(ev.currentTarget);
                    var $dialog;

                    if (el.hasClass('ngdialog')) {
                        $dialog = el;
                    } else {
                        $dialog = privateMethods.getActiveDialog();

                        if ($dialog === null) {
                            return;
                        }
                    }

                    var isTab = ev.keyCode === 9;
                    var backward = ev.shiftKey === true;

                    if (isTab) {
                        privateMethods.handleTab($dialog, ev, backward);
                    }
                },

                handleTab: function handleTab($dialog, ev, backward) {
                    var focusableElements = privateMethods.getFocusableElements($dialog);

                    if (focusableElements.length === 0) {
                        if (document.activeElement) {
                            document.activeElement.blur();
                        }
                        return;
                    }

                    var currentFocus = document.activeElement;
                    var focusIndex = Array.prototype.indexOf.call(focusableElements, currentFocus);

                    var isFocusIndexUnknown = focusIndex === -1;
                    var isFirstElementFocused = focusIndex === 0;
                    var isLastElementFocused = focusIndex === focusableElements.length - 1;

                    var cancelEvent = false;

                    if (backward) {
                        if (isFocusIndexUnknown || isFirstElementFocused) {
                            focusableElements[focusableElements.length - 1].focus();
                            cancelEvent = true;
                        }
                    } else {
                        if (isFocusIndexUnknown || isLastElementFocused) {
                            focusableElements[0].focus();
                            cancelEvent = true;
                        }
                    }

                    if (cancelEvent) {
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                },

                autoFocus: function autoFocus($dialog) {
                    var dialogEl = $dialog[0];

                    // Browser's (Chrome 40, Forefix 37, IE 11) don't appear to honor autofocus on the dialog, but we should
                    var autoFocusEl = dialogEl.querySelector('*[autofocus]');
                    if (autoFocusEl !== null) {
                        autoFocusEl.focus();

                        if (document.activeElement === autoFocusEl) {
                            return;
                        }

                        // Autofocus element might was display: none, so let's continue
                    }

                    var focusableElements = privateMethods.getFocusableElements($dialog);

                    if (focusableElements.length > 0) {
                        focusableElements[0].focus();
                        return;
                    }

                    // We need to focus something for the screen readers to notice the dialog
                    var contentElements = privateMethods.filterVisibleElements(dialogEl.querySelectorAll('h1,h2,h3,h4,h5,h6,p,span'));

                    if (contentElements.length > 0) {
                        var contentElement = contentElements[0];
                        $el(contentElement).attr('tabindex', '-1').css('outline', '0');
                        contentElement.focus();
                    }
                },

                getFocusableElements: function getFocusableElements($dialog) {
                    var dialogEl = $dialog[0];

                    var rawElements = dialogEl.querySelectorAll(focusableElementSelector);

                    // Ignore untabbable elements, ie. those with tabindex = -1
                    var tabbableElements = privateMethods.filterTabbableElements(rawElements);

                    return privateMethods.filterVisibleElements(tabbableElements);
                },

                filterTabbableElements: function filterTabbableElements(els) {
                    var tabbableFocusableElements = [];

                    for (var i = 0; i < els.length; i++) {
                        var el = els[i];

                        if ($el(el).attr('tabindex') !== '-1') {
                            tabbableFocusableElements.push(el);
                        }
                    }

                    return tabbableFocusableElements;
                },

                filterVisibleElements: function filterVisibleElements(els) {
                    var visibleFocusableElements = [];

                    for (var i = 0; i < els.length; i++) {
                        var el = els[i];

                        if (el.offsetWidth > 0 || el.offsetHeight > 0) {
                            visibleFocusableElements.push(el);
                        }
                    }

                    return visibleFocusableElements;
                },

                getActiveDialog: function getActiveDialog() {
                    var dialogs = document.querySelectorAll('.ngdialog');

                    if (dialogs.length === 0) {
                        return null;
                    }

                    // TODO: This might be incorrect if there are a mix of open dialogs with different 'appendTo' values
                    return $el(dialogs[dialogs.length - 1]);
                },

                applyAriaAttributes: function applyAriaAttributes($dialog, options) {
                    if (options.ariaAuto) {
                        if (!options.ariaRole) {
                            var detectedRole = privateMethods.getFocusableElements($dialog).length > 0 ? 'dialog' : 'alertdialog';

                            options.ariaRole = detectedRole;
                        }

                        if (!options.ariaLabelledBySelector) {
                            options.ariaLabelledBySelector = 'h1,h2,h3,h4,h5,h6';
                        }

                        if (!options.ariaDescribedBySelector) {
                            options.ariaDescribedBySelector = 'article,section,p';
                        }
                    }

                    if (options.ariaRole) {
                        $dialog.attr('role', options.ariaRole);
                    }

                    privateMethods.applyAriaAttribute($dialog, 'aria-labelledby', options.ariaLabelledById, options.ariaLabelledBySelector);

                    privateMethods.applyAriaAttribute($dialog, 'aria-describedby', options.ariaDescribedById, options.ariaDescribedBySelector);
                },

                applyAriaAttribute: function applyAriaAttribute($dialog, attr, id, selector) {
                    if (id) {
                        $dialog.attr(attr, id);
                    }

                    if (selector) {
                        var dialogId = $dialog.attr('id');

                        var firstMatch = $dialog[0].querySelector(selector);

                        if (!firstMatch) {
                            return;
                        }

                        var generatedId = dialogId + '-' + attr;

                        $el(firstMatch).attr('id', generatedId);

                        $dialog.attr(attr, generatedId);

                        return generatedId;
                    }
                },

                detectUIRouter: function detectUIRouter() {
                    //Detect if ui-router module is installed if not return false
                    try {
                        angular.module('ui.router');
                        return true;
                    } catch (err) {
                        return false;
                    }
                },

                getRouterLocationEventName: function getRouterLocationEventName() {
                    if (privateMethods.detectUIRouter()) {
                        return '$stateChangeSuccess';
                    }
                    return '$locationChangeSuccess';
                }
            };

            var publicMethods = {
                __PRIVATE__: privateMethods,

                /*
                 * @param {Object} options:
                 * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                 * - plain {Boolean} - enable plain string templates, default false
                 * - scope {Object}
                 * - controller {String}
                 * - controllerAs {String}
                 * - className {String} - dialog theme class
                 * - disableAnimation {Boolean} - set to true to disable animation
                 * - showClose {Boolean} - show close button, default true
                 * - closeByEscape {Boolean} - default true
                 * - closeByDocument {Boolean} - default true
                 * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set)
                 *
                 * @return {Object} dialog
                 */
                open: function open(opts) {
                    var options = angular.copy(defaults);
                    var localID = ++globalID;
                    var dialogID = 'ngdialog' + localID;
                    openIdStack.push(dialogID);

                    opts = opts || {};
                    angular.extend(options, opts);

                    var defer;
                    defers[dialogID] = defer = $q.defer();

                    var scope;
                    scopes[dialogID] = scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();

                    var $dialog, $dialogParent;

                    var resolve = angular.extend({}, options.resolve);

                    angular.forEach(resolve, function (value, key) {
                        resolve[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                    });

                    $q.all({
                        template: loadTemplate(options.template || options.templateUrl),
                        locals: $q.all(resolve)
                    }).then(function (setup) {
                        var template = setup.template,
                            locals = setup.locals;

                        if (options.showClose) {
                            template += '<div class="ngdialog-close"></div>';
                        }

                        var hasOverlayClass = options.overlay ? '' : ' ngdialog-no-overlay';
                        $dialog = $el('<div id="ngdialog' + localID + '" class="ngdialog' + hasOverlayClass + '"></div>');
                        $dialog.html(options.overlay ? '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + template + '</div>' : '<div class="ngdialog-content" role="document">' + template + '</div>');

                        $dialog.data('$ngDialogOptions', options);

                        scope.ngDialogId = dialogID;

                        if (options.data && angular.isString(options.data)) {
                            var firstLetter = options.data.replace(/^\s*/, '')[0];
                            scope.ngDialogData = firstLetter === '{' || firstLetter === '[' ? angular.fromJson(options.data) : options.data;
                            scope.ngDialogData.ngDialogId = dialogID;
                        } else if (options.data && angular.isObject(options.data)) {
                            scope.ngDialogData = options.data;
                            scope.ngDialogData.ngDialogId = dialogID;
                        }

                        if (options.className) {
                            $dialog.addClass(options.className);
                        }

                        if (options.disableAnimation) {
                            $dialog.addClass(disabledAnimationClass);
                        }

                        if (options.appendTo && angular.isString(options.appendTo)) {
                            $dialogParent = angular.element(document.querySelector(options.appendTo));
                        } else {
                            $dialogParent = $elements.body;
                        }

                        privateMethods.applyAriaAttributes($dialog, options);

                        if (options.preCloseCallback) {
                            var preCloseCallback;

                            if (angular.isFunction(options.preCloseCallback)) {
                                preCloseCallback = options.preCloseCallback;
                            } else if (angular.isString(options.preCloseCallback)) {
                                if (scope) {
                                    if (angular.isFunction(scope[options.preCloseCallback])) {
                                        preCloseCallback = scope[options.preCloseCallback];
                                    } else if (scope.$parent && angular.isFunction(scope.$parent[options.preCloseCallback])) {
                                        preCloseCallback = scope.$parent[options.preCloseCallback];
                                    } else if ($rootScope && angular.isFunction($rootScope[options.preCloseCallback])) {
                                        preCloseCallback = $rootScope[options.preCloseCallback];
                                    }
                                }
                            }

                            if (preCloseCallback) {
                                $dialog.data('$ngDialogPreCloseCallback', preCloseCallback);
                            }
                        }

                        scope.closeThisDialog = function (value) {
                            privateMethods.closeDialog($dialog, value);
                        };

                        if (options.controller && (angular.isString(options.controller) || angular.isArray(options.controller) || angular.isFunction(options.controller))) {

                            var label;

                            if (options.controllerAs && angular.isString(options.controllerAs)) {
                                label = options.controllerAs;
                            }

                            var controllerInstance = $controller(options.controller, angular.extend(locals, {
                                $scope: scope,
                                $element: $dialog
                            }), true, label);

                            if (options.bindToController) {
                                angular.extend(controllerInstance.instance, { ngDialogId: scope.ngDialogId, ngDialogData: scope.ngDialogData, closeThisDialog: scope.closeThisDialog });
                            }

                            $dialog.data('$ngDialogControllerController', controllerInstance());
                        }

                        $timeout(function () {
                            var $activeDialogs = document.querySelectorAll('.ngdialog');
                            privateMethods.deactivateAll($activeDialogs);

                            $compile($dialog)(scope);
                            var widthDiffs = $window.innerWidth - $elements.body.prop('clientWidth');
                            $elements.html.addClass('ngdialog-open');
                            $elements.body.addClass('ngdialog-open');
                            var scrollBarWidth = widthDiffs - ($window.innerWidth - $elements.body.prop('clientWidth'));
                            if (scrollBarWidth > 0) {
                                privateMethods.setBodyPadding(scrollBarWidth);
                            }
                            $dialogParent.append($dialog);

                            privateMethods.activate($dialog);

                            if (options.trapFocus) {
                                privateMethods.autoFocus($dialog);
                            }

                            if (options.name) {
                                $rootScope.$broadcast('ngDialog.opened', { dialog: $dialog, name: options.name });
                            } else {
                                $rootScope.$broadcast('ngDialog.opened', $dialog);
                            }
                        });

                        if (!keydownIsBound) {
                            $elements.body.bind('keydown', privateMethods.onDocumentKeydown);
                            keydownIsBound = true;
                        }

                        if (options.closeByNavigation) {
                            var eventName = privateMethods.getRouterLocationEventName();
                            $rootScope.$on(eventName, function () {
                                privateMethods.closeDialog($dialog);
                            });
                        }

                        if (options.preserveFocus) {
                            $dialog.data('$ngDialogPreviousFocus', document.activeElement);
                        }

                        closeByDocumentHandler = function (event) {
                            var isOverlay = options.closeByDocument ? $el(event.target).hasClass('ngdialog-overlay') : false;
                            var isCloseBtn = $el(event.target).hasClass('ngdialog-close');

                            if (isOverlay || isCloseBtn) {
                                publicMethods.close($dialog.attr('id'), isCloseBtn ? '$closeButton' : '$document');
                            }
                        };

                        if (typeof $window.Hammer !== 'undefined') {
                            var hammerTime = scope.hammerTime = $window.Hammer($dialog[0]);
                            hammerTime.on('tap', closeByDocumentHandler);
                        } else {
                            $dialog.bind('click', closeByDocumentHandler);
                        }

                        dialogsCount += 1;

                        return publicMethods;
                    });

                    return {
                        id: dialogID,
                        closePromise: defer.promise,
                        close: function close(value) {
                            privateMethods.closeDialog($dialog, value);
                        }
                    };

                    function loadTemplateUrl(tmpl, config) {
                        $rootScope.$broadcast('ngDialog.templateLoading', tmpl);
                        return $http.get(tmpl, config || {}).then(function (res) {
                            $rootScope.$broadcast('ngDialog.templateLoaded', tmpl);
                            return res.data || '';
                        });
                    }

                    function loadTemplate(tmpl) {
                        if (!tmpl) {
                            return 'Empty template';
                        }

                        if (angular.isString(tmpl) && options.plain) {
                            return tmpl;
                        }

                        if (typeof options.cache === 'boolean' && !options.cache) {
                            return loadTemplateUrl(tmpl, { cache: false });
                        }

                        return loadTemplateUrl(tmpl, { cache: $templateCache });
                    }
                },

                /*
                 * @param {Object} options:
                 * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                 * - plain {Boolean} - enable plain string templates, default false
                 * - name {String}
                 * - scope {Object}
                 * - controller {String}
                 * - controllerAs {String}
                 * - className {String} - dialog theme class
                 * - showClose {Boolean} - show close button, default true
                 * - closeByEscape {Boolean} - default false
                 * - closeByDocument {Boolean} - default false
                 * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set); not called on confirm
                 *
                 * @return {Object} dialog
                 */
                openConfirm: function openConfirm(opts) {
                    var defer = $q.defer();
                    var options = angular.copy(defaults);

                    opts = opts || {};
                    angular.extend(options, opts);

                    options.scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                    options.scope.confirm = function (value) {
                        defer.resolve(value);
                        var $dialog = $el(document.getElementById(openResult.id));
                        privateMethods.performCloseDialog($dialog, value);
                    };

                    var openResult = publicMethods.open(options);
                    openResult.closePromise.then(function (data) {
                        if (data) {
                            return defer.reject(data.value);
                        }
                        return defer.reject();
                    });

                    return defer.promise;
                },

                isOpen: function isOpen(id) {
                    var $dialog = $el(document.getElementById(id));
                    return $dialog.length > 0;
                },

                /*
                 * @param {String} id
                 * @return {Object} dialog
                 */
                close: function close(id, value) {
                    var $dialog = $el(document.getElementById(id));

                    if ($dialog.length) {
                        privateMethods.closeDialog($dialog, value);
                    } else {
                        if (id === '$escape') {
                            var topDialogId = openIdStack[openIdStack.length - 1];
                            $dialog = $el(document.getElementById(topDialogId));
                            if ($dialog.data('$ngDialogOptions').closeByEscape) {
                                privateMethods.closeDialog($dialog, '$escape');
                            }
                        } else {
                            publicMethods.closeAll(value);
                        }
                    }

                    return publicMethods;
                },

                closeAll: function closeAll(value) {
                    var $all = document.querySelectorAll('.ngdialog');

                    // Reverse order to ensure focus restoration works as expected
                    for (var i = $all.length - 1; i >= 0; i--) {
                        var dialog = $all[i];
                        privateMethods.closeDialog($el(dialog), value);
                    }
                },

                getOpenDialogs: function getOpenDialogs() {
                    return openIdStack;
                },

                getDefaults: function getDefaults() {
                    return defaults;
                }
            };

            angular.forEach(['html', 'body'], function (elementName) {
                $elements[elementName] = $document.find(elementName);
                if (forceElementsReload[elementName]) {
                    var eventName = privateMethods.getRouterLocationEventName();
                    $rootScope.$on(eventName, function () {
                        $elements[elementName] = $document.find(elementName);
                    });
                }
            });

            return publicMethods;
        }];
    });

    m.directive('ngDialog', ['ngDialog', function (ngDialog) {
        return {
            restrict: 'A',
            scope: {
                ngDialogScope: '='
            },
            link: function link(scope, elem, attrs) {
                elem.on('click', function (e) {
                    e.preventDefault();

                    var ngDialogScope = angular.isDefined(scope.ngDialogScope) ? scope.ngDialogScope : 'noScope';
                    angular.isDefined(attrs.ngDialogClosePrevious) && ngDialog.close(attrs.ngDialogClosePrevious);

                    var defaults = ngDialog.getDefaults();

                    ngDialog.open({
                        template: attrs.ngDialog,
                        className: attrs.ngDialogClass || defaults.className,
                        controller: attrs.ngDialogController,
                        controllerAs: attrs.ngDialogControllerAs,
                        bindToController: attrs.ngDialogBindToController,
                        scope: ngDialogScope,
                        data: attrs.ngDialogData,
                        showClose: attrs.ngDialogShowClose === 'false' ? false : attrs.ngDialogShowClose === 'true' ? true : defaults.showClose,
                        closeByDocument: attrs.ngDialogCloseByDocument === 'false' ? false : attrs.ngDialogCloseByDocument === 'true' ? true : defaults.closeByDocument,
                        closeByEscape: attrs.ngDialogCloseByEscape === 'false' ? false : attrs.ngDialogCloseByEscape === 'true' ? true : defaults.closeByEscape,
                        overlay: attrs.ngDialogOverlay === 'false' ? false : attrs.ngDialogOverlay === 'true' ? true : defaults.overlay,
                        preCloseCallback: attrs.ngDialogPreCloseCallback || defaults.preCloseCallback
                    });
                });
            }
        };
    }]);

    return m;
});
'use strict';

angular.module('app').controller('userHomeCtrl', ["$scope", "authService", "familyService", function ($scope, authService, familyService) {

	//Get authed user
	var getAuthedUser = function getAuthedUser() {
		authService.getAuthedUser().then(function (data) {
			$scope.authedUser = data;
			getAncestryAndChildren();
		});
	};
	getAuthedUser();

	//Get ancestry and children

	var getAncestryAndChildren = function getAncestryAndChildren() {
		familyService.getAncestryAndChildren($scope.authedUser.personId, $scope.authedUser.accessToken).then(function (data) {
			$scope.ancestryAndChildren = data;
			$scope.ancestry = familyService.returnAncestry();
			$scope.familyLength = $scope.ancestry.length;
			$scope.childrenLength = $scope.ancestryAndChildren.length;
		});
	};
}]);